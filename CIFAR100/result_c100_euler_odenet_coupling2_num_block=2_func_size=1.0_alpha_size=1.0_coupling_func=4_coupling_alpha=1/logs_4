/data4/zhangxiao/multi_scale_ODE/cifar100_coupling/ode_cifar100_coupling.py
import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
import torch.nn.functional as F

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=160)
parser.add_argument('--data_aug', type=eval, default=True, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.1)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=128)

parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
parser.add_argument('--method', type = str, choices=['euler', 'midpoint','dopri5','adaptive_heun'], default = 'euler')
parser.add_argument('--seed', type = int, default = 0)
parser.add_argument('--func', type=str, choices=['odetem','coupling','coupling2','temfunc'], default='odetem')
parser.add_argument('--num_block', type = int, default = 3)
parser.add_argument('--step_size', type=float, default=0.05)
parser.add_argument('--depth', type=float, default=1.0)
parser.add_argument('--hidden_dim', type=int, default=1000)
parser.add_argument('--coupling', type=int, default=2)
parser.add_argument('--coupling_func', type=int, default=2)
parser.add_argument('--coupling_alpha', type=int, default=1)
parser.add_argument('--func_size', type=float, default=1.0)
parser.add_argument('--alpha_size', type=float, default=1.0)


args = parser.parse_args()

import random
random.seed(args.seed)
np.random.seed(args.seed)
torch.manual_seed(args.seed)
torch.cuda.manual_seed_all(args.seed)
torch.backends.cudnn.deterministic = True
torch.backends.cudnn.benchmark = False

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.GroupNorm(min(32, dim), dim)


class ResBlock(nn.Module):
    expansion = 1

    def __init__(self, inplanes, planes, stride=1, downsample=None):
        super(ResBlock, self).__init__()
        self.norm1 = norm(inplanes)
        self.relu = nn.ReLU(inplace=True)
        self.downsample = downsample
        self.conv1 = conv3x3(inplanes, planes, stride)
        self.norm2 = norm(planes)
        self.conv2 = conv3x3(planes, planes)

    def forward(self, x):
        shortcut = x

        out = self.relu(self.norm1(x))

        if self.downsample is not None:
            shortcut = self.downsample(out)

        out = self.conv1(out)
        out = self.norm2(out)
        out = self.relu(out)
        out = self.conv2(out)

        return out + shortcut


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self, dim, kernel_size):
        super(ODEfunc, self).__init__()
        self.norm1 = norm(dim)
        self.relu = nn.ReLU(inplace=True)
        self.conv1 = ConcatConv2d(dim, dim, kernel_size, 1, (kernel_size//2))
        self.norm2 = norm(dim)
        self.conv2 = ConcatConv2d(dim, dim, kernel_size, 1, (kernel_size//2))
        self.norm3 = norm(dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.norm1(x)
        out = self.relu(out)
        out = self.conv1(t, out)
        out = self.norm2(out)
        out = self.relu(out)
        out = self.conv2(t, out)
        out = self.norm3(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value

##############################kernel_size=1,3,5,7,9 结合TEM,异步耦合###################
class ODEBlock_coupling(nn.Module):

    def __init__(self, dim):
        super(ODEBlock_coupling, self).__init__()
        self.odefunc = nn.ModuleList([ODEfunc(dim, 3).to(device),ODEfunc(dim, 5).to(device),ODEfunc(dim, 7).to(device)])
        self.alphafc = nn.Sequential(nn.Linear(args.num_block, args.hidden_dim), nn.Tanh(), nn.Linear(args.hidden_dim, args.num_block))

    def forward(self, x):
        num_step = int(args.depth/args.step_size)
        out = x; t = 0.0
        alpha = torch.ones(args.num_block).to(device) / args.num_block
        for i in range(num_step):
            dhdt = 0
            weight = F.softmax(alpha, dim=-1)
            if i % args.coupling_func == 0:
                for j in range(args.num_block):
                    dhdt = dhdt + self.odefunc[j](t,out) * weight[j]
                out = out + dhdt * args.step_size * args.func_size
            if i % args.coupling_alpha == 0:
                alpha = alpha + self.alphafc(alpha.unsqueeze(0)).squeeze() * args.step_size  * args.alpha_size
            t = t + args.step_size
        return out
##############################kernel_size=1,3,5,7,9 结合TEM,异步耦合    2    ###################
class ODEBlock_coupling2(nn.Module):

    def __init__(self, dim):
        super(ODEBlock_coupling2, self).__init__()
        self.odefunc = nn.ModuleList([ODEfunc(dim, 3).to(device),ODEfunc(dim, 5).to(device)])#,ODEfunc(dim, 7).to(device)
        self.alphafc = nn.Sequential(nn.Linear(args.num_block, args.hidden_dim), nn.Tanh(), nn.Linear(args.hidden_dim, args.num_block))

    def forward(self, x):
        num_step = int(args.depth/args.step_size)
        out = x; t = 0.0
        alpha = torch.ones(args.num_block).to(device) / args.num_block
        for i in range(num_step):
            dhdt = 0
            weight = F.softmax(alpha, dim=-1)
            if i % args.coupling_func == 0:
                for j in range(args.num_block):
                    dhdt = dhdt + self.odefunc[j](t,out) * weight[j]
                out = out + dhdt * args.step_size * args.func_size
            if i % args.coupling_alpha == 0:
                alpha = alpha + self.alphafc(alpha.unsqueeze(0)).squeeze() * args.step_size  * args.alpha_size
            t = t + args.step_size
        return out
##############################kernel_size=1,3,5,7,9 结合TEM,异步耦合###################
class ODEBlock_tem_func(nn.Module):

    def __init__(self, dim):
        super(ODEBlock_tem_func, self).__init__()
        self.odefunc = nn.ModuleList([ODEfunc(dim, 3).to(device), ODEfunc(dim, 5).to(device), ODEfunc(dim, 7).to(device)])
        self.alphafc = nn.Sequential(nn.Linear(args.num_block, args.hidden_dim), nn.Tanh(), nn.Linear(args.hidden_dim, args.num_block))

    def forward(self, x):
        num_step = int(args.depth/args.step_size)
        out = x; t = 0.0
        alpha = torch.ones(args.num_block).to(device) / args.num_block
        for i in range(num_step):
            dhdt = 0
            weight = F.softmax(alpha, dim=-1)
            if i % args.coupling == 0:
                for j in range(args.num_block):
                    dhdt = dhdt + self.odefunc[j](t,out) * weight[j]
                out = out + dhdt * args.step_size * 2
            alpha = alpha + self.alphafc(alpha.unsqueeze(0)).squeeze() * args.step_size
            t = t + args.step_size
        return out

##############################TEM###################
class ODEBlock(nn.Module):

    def __init__(self, dim):
        super(ODEBlock, self).__init__()
        self.odefunc = nn.ModuleList([ODEfunc(dim,3).to(device) for _ in range(args.num_block)])
        self.alphafc = nn.Sequential(nn.Linear(args.num_block, args.hidden_dim), nn.Tanh(), nn.Linear(args.hidden_dim, args.num_block))

    def forward(self, x):
        num_step = int(args.depth/args.step_size)
        out = x; t = 0.0
        alpha = torch.ones(args.num_block).to(device) / args.num_block
        for i in range(num_step):
            dhdt = 0
            weight = F.softmax(alpha, dim=-1)
            if i % args.coupling_func == 0:
                for j in range(args.num_block):
                    dhdt = dhdt + self.odefunc[j](t,out) * weight[j]
                out = out + dhdt * args.step_size * args.func_size
            if i % args.coupling_alpha == 0:
                alpha = alpha + self.alphafc(alpha.unsqueeze(0)).squeeze() * args.step_size  * args.alpha_size
            t = t + args.step_size
        return out

class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val

def get_cifar100_loaders(data_aug=False, batch_size=128, test_batch_size=128, perc=1.0):
    normalize = transforms.Normalize(mean=[0.485, 0.456, 0.406],
                                     std=[0.229, 0.224, 0.225])
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomHorizontalFlip(),
            transforms.RandomCrop(32, padding=4),
            transforms.ToTensor(),
            normalize,
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
            normalize,
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
            normalize,
    ])

    train_loader = DataLoader(
        datasets.CIFAR100(root='/data1/XIAO_XIAO/NODE/example-y0-noise/data', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR100(root='/data1/XIAO_XIAO/NODE/example-y0-noise/data', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, None


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)

def accuracy(model, dataset_loader):
    correct_1 = 0.0
    correct_5 = 0.0
    for x, y in dataset_loader:
        x = x.to(device)
        y = y.to(device)

        output = model(x)

        _, pred = output.topk(5, 1, largest=True, sorted=True)
        label = y.view(y.size(0), -1).expand_as(pred)
        correct = pred.eq(label).float()
        ####compute top1
        correct_1 += correct[:,:1].sum()
        ####compute top5
        correct_5 += correct[:,:5].sum()

    return correct_1 / len(dataset_loader.dataset), correct_5 / len(dataset_loader.dataset)

def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):  # 判断是否需要创建文件夹,存在则跳过
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger
from thop import profile

if __name__ == '__main__':

    path_seed = './result_c100_{}_{}_{}_num_block={}_func_size={}_alpha_size={}_coupling_func={}_coupling_alpha={}'.format(args.method, args.network, args.func, args.num_block, args.func_size,  args.alpha_size, args.coupling_func, args.coupling_alpha)
    if not os.path.isdir(path_seed):
        os.makedirs(path_seed)
    makedirs(path_seed)
    logger = get_logger(logpath=os.path.join(path_seed, 'logs_{}'.format(args.seed)), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    if args.downsampling_method == 'conv':
        downsampling_layers = [
            nn.Conv2d(3, 64, 3, 1),
            norm(64),
            nn.ReLU(inplace=True),
            nn.Conv2d(64, 64, 4, 2, 1),
            norm(64),
            nn.ReLU(inplace=True),
            nn.Conv2d(64, 64, 4, 2, 1),
        ]
    elif args.downsampling_method == 'res':
        downsampling_layers = [
            nn.Conv2d(3, 64, 3, 1),
            ResBlock(64, 64, stride=2, downsample=conv1x1(64, 64, 2)),
            ResBlock(64, 64, stride=2, downsample=conv1x1(64, 64, 2)),
        ]
    
    if args.func == 'odetem':
        feature_layers = [ODEBlock(64)] if is_odenet else [ResBlock(64, 64) for _ in range(6)]
    if args.func == 'coupling':
        feature_layers = [ODEBlock_coupling(64)] if is_odenet else [ResBlock(64, 64) for _ in range(6)]
    if args.func == 'coupling2':
        feature_layers = [ODEBlock_coupling2(64)] if is_odenet else [ResBlock(64, 64) for _ in range(6)]
    if args.func == 'temfunc':
        feature_layers = [ODEBlock_tem_func(64)] if is_odenet else [ResBlock(64, 64) for _ in range(6)]
    fc_layers = [norm(64), nn.ReLU(inplace=True), nn.AdaptiveAvgPool2d((1, 1)), Flatten(), nn.Linear(64, 100)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)
    x = torch.randn(1, 3, 28, 28).to(device)
    flops, params = profile(model, inputs=(x,))
    print('flops  of ODE is %.2fG' % (flops/1e9))
    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar100_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    inference_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        loss.backward()
        optimizer.step()

        batch_time_meter.update(time.time() - end)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc1, train_acc5 = accuracy(model, train_loader)
                inference_end = time.time()
                val_acc1, val_acc5 = accuracy(model, test_loader)
                inference_time_meter.update(time.time() - inference_end)
                if val_acc1 > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(path_seed, 'model_{}.pth'.format(args.seed)))
                    best_acc = val_acc1
                logger.info(
                    "Epoch {:04d} | " "Train_1 Acc {:.4f} | Train_5 Acc {:.4f} | Test_1 Acc {:.4f} | Test_5 Acc {:.4f} |Train Time {:.3f} ({:.3f}) |Test Time {:.3f} ({:.3f})".format(
                        itr // batches_per_epoch, train_acc1, train_acc5, val_acc1, val_acc5, batch_time_meter.val, batch_time_meter.avg, inference_time_meter.val, inference_time_meter.avg
                    )
                )

Namespace(adjoint=False, alpha_size=1.0, batch_size=128, coupling=2, coupling_alpha=1, coupling_func=4, data_aug=True, debug=False, depth=1.0, downsampling_method='conv', func='coupling2', func_size=1.0, gpu=1, hidden_dim=1000, lr=0.1, method='euler', nepochs=160, network='odenet', num_block=2, seed=4, step_size=0.05, test_batch_size=128, tol=0.001)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): GroupNorm(32, 64, eps=1e-05, affine=True)
  (2): ReLU(inplace=True)
  (3): Conv2d(64, 64, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (4): GroupNorm(32, 64, eps=1e-05, affine=True)
  (5): ReLU(inplace=True)
  (6): Conv2d(64, 64, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (7): ODEBlock_coupling2(
    (odefunc): ModuleList(
      (0): ODEfunc(
        (norm1): GroupNorm(32, 64, eps=1e-05, affine=True)
        (relu): ReLU(inplace=True)
        (conv1): ConcatConv2d(
          (_layer): Conv2d(65, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        )
        (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)
        (conv2): ConcatConv2d(
          (_layer): Conv2d(65, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        )
        (norm3): GroupNorm(32, 64, eps=1e-05, affine=True)
      )
      (1): ODEfunc(
        (norm1): GroupNorm(32, 64, eps=1e-05, affine=True)
        (relu): ReLU(inplace=True)
        (conv1): ConcatConv2d(
          (_layer): Conv2d(65, 64, kernel_size=(5, 5), stride=(1, 1), padding=(2, 2))
        )
        (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)
        (conv2): ConcatConv2d(
          (_layer): Conv2d(65, 64, kernel_size=(5, 5), stride=(1, 1), padding=(2, 2))
        )
        (norm3): GroupNorm(32, 64, eps=1e-05, affine=True)
      )
    )
    (alphafc): Sequential(
      (0): Linear(in_features=2, out_features=1000, bias=True)
      (1): Tanh()
      (2): Linear(in_features=1000, out_features=2, bias=True)
    )
  )
  (8): GroupNorm(32, 64, eps=1e-05, affine=True)
  (9): ReLU(inplace=True)
  (10): AdaptiveAvgPool2d(output_size=(1, 1))
  (11): Flatten()
  (12): Linear(in_features=64, out_features=100, bias=True)
)
Number of parameters: 428782
Epoch 0000 | Train_1 Acc 0.0103 | Train_5 Acc 0.0499 | Test_1 Acc 0.0110 | Test_5 Acc 0.0500 |Train Time 0.325 (0.325) |Test Time 2.223 (2.223)
/data4/zhangxiao/multi_scale_ODE/cifar100_coupling/ode_cifar100_coupling.py
import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
import torch.nn.functional as F

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=160)
parser.add_argument('--data_aug', type=eval, default=True, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.1)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=128)

parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
parser.add_argument('--method', type = str, choices=['euler', 'midpoint','dopri5','adaptive_heun'], default = 'euler')
parser.add_argument('--seed', type = int, default = 0)
parser.add_argument('--func', type=str, choices=['odetem','coupling','coupling2','temfunc'], default='odetem')
parser.add_argument('--num_block', type = int, default = 3)
parser.add_argument('--step_size', type=float, default=0.05)
parser.add_argument('--depth', type=float, default=1.0)
parser.add_argument('--hidden_dim', type=int, default=1000)
parser.add_argument('--coupling', type=int, default=2)
parser.add_argument('--coupling_func', type=int, default=2)
parser.add_argument('--coupling_alpha', type=int, default=1)
parser.add_argument('--func_size', type=float, default=1.0)
parser.add_argument('--alpha_size', type=float, default=1.0)


args = parser.parse_args()

import random
random.seed(args.seed)
np.random.seed(args.seed)
torch.manual_seed(args.seed)
torch.cuda.manual_seed_all(args.seed)
torch.backends.cudnn.deterministic = True
torch.backends.cudnn.benchmark = False

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.GroupNorm(min(32, dim), dim)


class ResBlock(nn.Module):
    expansion = 1

    def __init__(self, inplanes, planes, stride=1, downsample=None):
        super(ResBlock, self).__init__()
        self.norm1 = norm(inplanes)
        self.relu = nn.ReLU(inplace=True)
        self.downsample = downsample
        self.conv1 = conv3x3(inplanes, planes, stride)
        self.norm2 = norm(planes)
        self.conv2 = conv3x3(planes, planes)

    def forward(self, x):
        shortcut = x

        out = self.relu(self.norm1(x))

        if self.downsample is not None:
            shortcut = self.downsample(out)

        out = self.conv1(out)
        out = self.norm2(out)
        out = self.relu(out)
        out = self.conv2(out)

        return out + shortcut


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self, dim, kernel_size):
        super(ODEfunc, self).__init__()
        self.norm1 = norm(dim)
        self.relu = nn.ReLU(inplace=True)
        self.conv1 = ConcatConv2d(dim, dim, kernel_size, 1, (kernel_size//2))
        self.norm2 = norm(dim)
        self.conv2 = ConcatConv2d(dim, dim, kernel_size, 1, (kernel_size//2))
        self.norm3 = norm(dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.norm1(x)
        out = self.relu(out)
        out = self.conv1(t, out)
        out = self.norm2(out)
        out = self.relu(out)
        out = self.conv2(t, out)
        out = self.norm3(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value

##############################kernel_size=1,3,5,7,9 结合TEM,异步耦合###################
class ODEBlock_coupling(nn.Module):

    def __init__(self, dim):
        super(ODEBlock_coupling, self).__init__()
        self.odefunc = nn.ModuleList([ODEfunc(dim, 3).to(device),ODEfunc(dim, 5).to(device),ODEfunc(dim, 7).to(device)])
        self.alphafc = nn.Sequential(nn.Linear(args.num_block, args.hidden_dim), nn.Tanh(), nn.Linear(args.hidden_dim, args.num_block))

    def forward(self, x):
        num_step = int(args.depth/args.step_size)
        out = x; t = 0.0
        alpha = torch.ones(args.num_block).to(device) / args.num_block
        for i in range(num_step):
            dhdt = 0
            weight = F.softmax(alpha, dim=-1)
            if i % args.coupling_func == 0:
                for j in range(args.num_block):
                    dhdt = dhdt + self.odefunc[j](t,out) * weight[j]
                out = out + dhdt * args.step_size * args.func_size
            if i % args.coupling_alpha == 0:
                alpha = alpha + self.alphafc(alpha.unsqueeze(0)).squeeze() * args.step_size  * args.alpha_size
            t = t + args.step_size
        return out
##############################kernel_size=1,3,5,7,9 结合TEM,异步耦合    2    ###################
class ODEBlock_coupling2(nn.Module):

    def __init__(self, dim):
        super(ODEBlock_coupling2, self).__init__()
        self.odefunc = nn.ModuleList([ODEfunc(dim, 3).to(device),ODEfunc(dim, 5).to(device)])#,ODEfunc(dim, 7).to(device)
        self.alphafc = nn.Sequential(nn.Linear(args.num_block, args.hidden_dim), nn.Tanh(), nn.Linear(args.hidden_dim, args.num_block))

    def forward(self, x):
        num_step = int(args.depth/args.step_size)
        out = x; t = 0.0
        alpha = torch.ones(args.num_block).to(device) / args.num_block
        for i in range(num_step):
            dhdt = 0
            weight = F.softmax(alpha, dim=-1)
            if i % args.coupling_func == 0:
                for j in range(args.num_block):
                    dhdt = dhdt + self.odefunc[j](t,out) * weight[j]
                out = out + dhdt * args.step_size * args.func_size
            if i % args.coupling_alpha == 0:
                alpha = alpha + self.alphafc(alpha.unsqueeze(0)).squeeze() * args.step_size  * args.alpha_size
            t = t + args.step_size
        return out
##############################kernel_size=1,3,5,7,9 结合TEM,异步耦合###################
class ODEBlock_tem_func(nn.Module):

    def __init__(self, dim):
        super(ODEBlock_tem_func, self).__init__()
        self.odefunc = nn.ModuleList([ODEfunc(dim, 3).to(device), ODEfunc(dim, 5).to(device), ODEfunc(dim, 7).to(device)])
        self.alphafc = nn.Sequential(nn.Linear(args.num_block, args.hidden_dim), nn.Tanh(), nn.Linear(args.hidden_dim, args.num_block))

    def forward(self, x):
        num_step = int(args.depth/args.step_size)
        out = x; t = 0.0
        alpha = torch.ones(args.num_block).to(device) / args.num_block
        for i in range(num_step):
            dhdt = 0
            weight = F.softmax(alpha, dim=-1)
            if i % args.coupling == 0:
                for j in range(args.num_block):
                    dhdt = dhdt + self.odefunc[j](t,out) * weight[j]
                out = out + dhdt * args.step_size * 2
            alpha = alpha + self.alphafc(alpha.unsqueeze(0)).squeeze() * args.step_size
            t = t + args.step_size
        return out

##############################TEM###################
class ODEBlock(nn.Module):

    def __init__(self, dim):
        super(ODEBlock, self).__init__()
        self.odefunc = nn.ModuleList([ODEfunc(dim,3).to(device) for _ in range(args.num_block)])
        self.alphafc = nn.Sequential(nn.Linear(args.num_block, args.hidden_dim), nn.Tanh(), nn.Linear(args.hidden_dim, args.num_block))

    def forward(self, x):
        num_step = int(args.depth/args.step_size)
        out = x; t = 0.0
        alpha = torch.ones(args.num_block).to(device) / args.num_block
        for i in range(num_step):
            dhdt = 0
            weight = F.softmax(alpha, dim=-1)
            if i % args.coupling_func == 0:
                for j in range(args.num_block):
                    dhdt = dhdt + self.odefunc[j](t,out) * weight[j]
                out = out + dhdt * args.step_size * args.func_size
            if i % args.coupling_alpha == 0:
                alpha = alpha + self.alphafc(alpha.unsqueeze(0)).squeeze() * args.step_size  * args.alpha_size
            t = t + args.step_size
        return out

class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val

def get_cifar100_loaders(data_aug=False, batch_size=128, test_batch_size=128, perc=1.0):
    normalize = transforms.Normalize(mean=[0.485, 0.456, 0.406],
                                     std=[0.229, 0.224, 0.225])
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomHorizontalFlip(),
            transforms.RandomCrop(32, padding=4),
            transforms.ToTensor(),
            normalize,
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
            normalize,
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
            normalize,
    ])

    train_loader = DataLoader(
        datasets.CIFAR100(root='/data1/XIAO_XIAO/NODE/example-y0-noise/data', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR100(root='/data1/XIAO_XIAO/NODE/example-y0-noise/data', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, None


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)

def accuracy(model, dataset_loader):
    correct_1 = 0.0
    correct_5 = 0.0
    for x, y in dataset_loader:
        x = x.to(device)
        y = y.to(device)

        output = model(x)

        _, pred = output.topk(5, 1, largest=True, sorted=True)
        label = y.view(y.size(0), -1).expand_as(pred)
        correct = pred.eq(label).float()
        ####compute top1
        correct_1 += correct[:,:1].sum()
        ####compute top5
        correct_5 += correct[:,:5].sum()

    return correct_1 / len(dataset_loader.dataset), correct_5 / len(dataset_loader.dataset)

def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):  # 判断是否需要创建文件夹,存在则跳过
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger
from thop import profile

if __name__ == '__main__':

    path_seed = './result_c100_{}_{}_{}_num_block={}_func_size={}_alpha_size={}_coupling_func={}_coupling_alpha={}'.format(args.method, args.network, args.func, args.num_block, args.func_size,  args.alpha_size, args.coupling_func, args.coupling_alpha)
    if not os.path.isdir(path_seed):
        os.makedirs(path_seed)
    makedirs(path_seed)
    logger = get_logger(logpath=os.path.join(path_seed, 'logs_{}'.format(args.seed)), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    if args.downsampling_method == 'conv':
        downsampling_layers = [
            nn.Conv2d(3, 64, 3, 1),
            norm(64),
            nn.ReLU(inplace=True),
            nn.Conv2d(64, 64, 4, 2, 1),
            norm(64),
            nn.ReLU(inplace=True),
            nn.Conv2d(64, 64, 4, 2, 1),
        ]
    elif args.downsampling_method == 'res':
        downsampling_layers = [
            nn.Conv2d(3, 64, 3, 1),
            ResBlock(64, 64, stride=2, downsample=conv1x1(64, 64, 2)),
            ResBlock(64, 64, stride=2, downsample=conv1x1(64, 64, 2)),
        ]
    
    if args.func == 'odetem':
        feature_layers = [ODEBlock(64)] if is_odenet else [ResBlock(64, 64) for _ in range(6)]
    if args.func == 'coupling':
        feature_layers = [ODEBlock_coupling(64)] if is_odenet else [ResBlock(64, 64) for _ in range(6)]
    if args.func == 'coupling2':
        feature_layers = [ODEBlock_coupling2(64)] if is_odenet else [ResBlock(64, 64) for _ in range(6)]
    if args.func == 'temfunc':
        feature_layers = [ODEBlock_tem_func(64)] if is_odenet else [ResBlock(64, 64) for _ in range(6)]
    fc_layers = [norm(64), nn.ReLU(inplace=True), nn.AdaptiveAvgPool2d((1, 1)), Flatten(), nn.Linear(64, 100)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)
    x = torch.randn(1, 3, 28, 28).to(device)
    flops, params = profile(model, inputs=(x,))
    print('flops  of ODE is %.2fG' % (flops/1e9))
    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar100_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    inference_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        loss.backward()
        optimizer.step()

        batch_time_meter.update(time.time() - end)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc1, train_acc5 = accuracy(model, train_loader)
                inference_end = time.time()
                val_acc1, val_acc5 = accuracy(model, test_loader)
                inference_time_meter.update(time.time() - inference_end)
                if val_acc1 > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(path_seed, 'model_{}.pth'.format(args.seed)))
                    best_acc = val_acc1
                logger.info(
                    "Epoch {:04d} | " "Train_1 Acc {:.4f} | Train_5 Acc {:.4f} | Test_1 Acc {:.4f} | Test_5 Acc {:.4f} |Train Time {:.3f} ({:.3f}) |Test Time {:.3f} ({:.3f})".format(
                        itr // batches_per_epoch, train_acc1, train_acc5, val_acc1, val_acc5, batch_time_meter.val, batch_time_meter.avg, inference_time_meter.val, inference_time_meter.avg
                    )
                )

Namespace(adjoint=False, alpha_size=1.0, batch_size=128, coupling=2, coupling_alpha=1, coupling_func=4, data_aug=True, debug=False, depth=1.0, downsampling_method='conv', func='coupling2', func_size=1.0, gpu=3, hidden_dim=1000, lr=0.1, method='euler', nepochs=160, network='odenet', num_block=2, seed=4, step_size=0.05, test_batch_size=128, tol=0.001)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): GroupNorm(32, 64, eps=1e-05, affine=True)
  (2): ReLU(inplace=True)
  (3): Conv2d(64, 64, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (4): GroupNorm(32, 64, eps=1e-05, affine=True)
  (5): ReLU(inplace=True)
  (6): Conv2d(64, 64, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (7): ODEBlock_coupling2(
    (odefunc): ModuleList(
      (0): ODEfunc(
        (norm1): GroupNorm(32, 64, eps=1e-05, affine=True)
        (relu): ReLU(inplace=True)
        (conv1): ConcatConv2d(
          (_layer): Conv2d(65, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        )
        (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)
        (conv2): ConcatConv2d(
          (_layer): Conv2d(65, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        )
        (norm3): GroupNorm(32, 64, eps=1e-05, affine=True)
      )
      (1): ODEfunc(
        (norm1): GroupNorm(32, 64, eps=1e-05, affine=True)
        (relu): ReLU(inplace=True)
        (conv1): ConcatConv2d(
          (_layer): Conv2d(65, 64, kernel_size=(5, 5), stride=(1, 1), padding=(2, 2))
        )
        (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)
        (conv2): ConcatConv2d(
          (_layer): Conv2d(65, 64, kernel_size=(5, 5), stride=(1, 1), padding=(2, 2))
        )
        (norm3): GroupNorm(32, 64, eps=1e-05, affine=True)
      )
    )
    (alphafc): Sequential(
      (0): Linear(in_features=2, out_features=1000, bias=True)
      (1): Tanh()
      (2): Linear(in_features=1000, out_features=2, bias=True)
    )
  )
  (8): GroupNorm(32, 64, eps=1e-05, affine=True)
  (9): ReLU(inplace=True)
  (10): AdaptiveAvgPool2d(output_size=(1, 1))
  (11): Flatten()
  (12): Linear(in_features=64, out_features=100, bias=True)
)
Number of parameters: 428782
Epoch 0000 | Train_1 Acc 0.0103 | Train_5 Acc 0.0499 | Test_1 Acc 0.0110 | Test_5 Acc 0.0500 |Train Time 0.328 (0.328) |Test Time 1.739 (1.739)
Epoch 0001 | Train_1 Acc 0.0930 | Train_5 Acc 0.3124 | Test_1 Acc 0.0911 | Test_5 Acc 0.3069 |Train Time 0.351 (0.068) |Test Time 1.969 (1.742)
Epoch 0002 | Train_1 Acc 0.1600 | Train_5 Acc 0.4303 | Test_1 Acc 0.1557 | Test_5 Acc 0.4022 |Train Time 0.351 (0.061) |Test Time 1.862 (1.743)
Epoch 0003 | Train_1 Acc 0.2246 | Train_5 Acc 0.5141 | Test_1 Acc 0.2100 | Test_5 Acc 0.5015 |Train Time 0.339 (0.058) |Test Time 1.948 (1.745)
Epoch 0004 | Train_1 Acc 0.2513 | Train_5 Acc 0.5581 | Test_1 Acc 0.2271 | Test_5 Acc 0.5304 |Train Time 0.369 (0.060) |Test Time 1.819 (1.746)
Epoch 0005 | Train_1 Acc 0.2905 | Train_5 Acc 0.6079 | Test_1 Acc 0.2704 | Test_5 Acc 0.5859 |Train Time 0.379 (0.059) |Test Time 2.342 (1.751)
Epoch 0006 | Train_1 Acc 0.3301 | Train_5 Acc 0.6521 | Test_1 Acc 0.3087 | Test_5 Acc 0.6253 |Train Time 0.403 (0.060) |Test Time 1.869 (1.753)
Epoch 0007 | Train_1 Acc 0.3348 | Train_5 Acc 0.6571 | Test_1 Acc 0.3173 | Test_5 Acc 0.6348 |Train Time 0.367 (0.060) |Test Time 1.979 (1.755)
Epoch 0008 | Train_1 Acc 0.3727 | Train_5 Acc 0.6911 | Test_1 Acc 0.3465 | Test_5 Acc 0.6644 |Train Time 0.341 (0.060) |Test Time 1.804 (1.755)
Epoch 0009 | Train_1 Acc 0.3667 | Train_5 Acc 0.6942 | Test_1 Acc 0.3476 | Test_5 Acc 0.6727 |Train Time 0.371 (0.061) |Test Time 2.096 (1.759)
Epoch 0010 | Train_1 Acc 0.4020 | Train_5 Acc 0.7296 | Test_1 Acc 0.3777 | Test_5 Acc 0.7017 |Train Time 0.492 (0.062) |Test Time 1.959 (1.761)
Epoch 0011 | Train_1 Acc 0.4010 | Train_5 Acc 0.7285 | Test_1 Acc 0.3740 | Test_5 Acc 0.7016 |Train Time 0.330 (0.059) |Test Time 1.943 (1.763)
Epoch 0012 | Train_1 Acc 0.4233 | Train_5 Acc 0.7471 | Test_1 Acc 0.3975 | Test_5 Acc 0.7168 |Train Time 0.380 (0.058) |Test Time 1.987 (1.765)
Epoch 0013 | Train_1 Acc 0.4378 | Train_5 Acc 0.7566 | Test_1 Acc 0.4101 | Test_5 Acc 0.7304 |Train Time 0.386 (0.058) |Test Time 1.836 (1.766)
Epoch 0014 | Train_1 Acc 0.4517 | Train_5 Acc 0.7665 | Test_1 Acc 0.4104 | Test_5 Acc 0.7283 |Train Time 0.381 (0.061) |Test Time 1.790 (1.766)
Epoch 0015 | Train_1 Acc 0.4549 | Train_5 Acc 0.7687 | Test_1 Acc 0.4221 | Test_5 Acc 0.7303 |Train Time 0.351 (0.057) |Test Time 1.908 (1.767)
Epoch 0016 | Train_1 Acc 0.4520 | Train_5 Acc 0.7670 | Test_1 Acc 0.4106 | Test_5 Acc 0.7282 |Train Time 0.354 (0.060) |Test Time 2.137 (1.771)
Epoch 0017 | Train_1 Acc 0.4779 | Train_5 Acc 0.7916 | Test_1 Acc 0.4344 | Test_5 Acc 0.7519 |Train Time 0.378 (0.061) |Test Time 1.868 (1.772)
Epoch 0018 | Train_1 Acc 0.4697 | Train_5 Acc 0.7875 | Test_1 Acc 0.4343 | Test_5 Acc 0.7465 |Train Time 0.393 (0.061) |Test Time 1.792 (1.772)
Epoch 0019 | Train_1 Acc 0.4951 | Train_5 Acc 0.8077 | Test_1 Acc 0.4408 | Test_5 Acc 0.7567 |Train Time 0.326 (0.056) |Test Time 2.354 (1.778)
Epoch 0020 | Train_1 Acc 0.5108 | Train_5 Acc 0.8158 | Test_1 Acc 0.4595 | Test_5 Acc 0.7645 |Train Time 0.365 (0.061) |Test Time 1.942 (1.780)
Epoch 0021 | Train_1 Acc 0.4760 | Train_5 Acc 0.7859 | Test_1 Acc 0.4371 | Test_5 Acc 0.7435 |Train Time 0.340 (0.059) |Test Time 1.851 (1.780)
Epoch 0022 | Train_1 Acc 0.5180 | Train_5 Acc 0.8208 | Test_1 Acc 0.4655 | Test_5 Acc 0.7723 |Train Time 0.396 (0.060) |Test Time 2.181 (1.784)
Epoch 0023 | Train_1 Acc 0.5185 | Train_5 Acc 0.8232 | Test_1 Acc 0.4633 | Test_5 Acc 0.7671 |Train Time 0.485 (0.058) |Test Time 1.692 (1.783)
Epoch 0024 | Train_1 Acc 0.5241 | Train_5 Acc 0.8288 | Test_1 Acc 0.4688 | Test_5 Acc 0.7733 |Train Time 0.387 (0.061) |Test Time 1.754 (1.783)
Epoch 0025 | Train_1 Acc 0.5370 | Train_5 Acc 0.8330 | Test_1 Acc 0.4855 | Test_5 Acc 0.7817 |Train Time 0.337 (0.061) |Test Time 2.444 (1.790)
Epoch 0026 | Train_1 Acc 0.5313 | Train_5 Acc 0.8290 | Test_1 Acc 0.4685 | Test_5 Acc 0.7696 |Train Time 0.368 (0.064) |Test Time 2.143 (1.793)
Epoch 0027 | Train_1 Acc 0.5366 | Train_5 Acc 0.8325 | Test_1 Acc 0.4777 | Test_5 Acc 0.7786 |Train Time 0.383 (0.064) |Test Time 1.926 (1.795)
Epoch 0028 | Train_1 Acc 0.5308 | Train_5 Acc 0.8295 | Test_1 Acc 0.4713 | Test_5 Acc 0.7707 |Train Time 0.370 (0.066) |Test Time 2.126 (1.798)
Epoch 0029 | Train_1 Acc 0.5395 | Train_5 Acc 0.8362 | Test_1 Acc 0.4697 | Test_5 Acc 0.7795 |Train Time 0.358 (0.064) |Test Time 2.094 (1.801)
Epoch 0030 | Train_1 Acc 0.5601 | Train_5 Acc 0.8498 | Test_1 Acc 0.4986 | Test_5 Acc 0.7898 |Train Time 0.410 (0.068) |Test Time 2.169 (1.805)
Epoch 0031 | Train_1 Acc 0.5464 | Train_5 Acc 0.8411 | Test_1 Acc 0.4762 | Test_5 Acc 0.7775 |Train Time 0.480 (0.068) |Test Time 2.434 (1.811)
Epoch 0032 | Train_1 Acc 0.5461 | Train_5 Acc 0.8462 | Test_1 Acc 0.4763 | Test_5 Acc 0.7791 |Train Time 0.373 (0.066) |Test Time 2.179 (1.814)
Epoch 0033 | Train_1 Acc 0.5613 | Train_5 Acc 0.8495 | Test_1 Acc 0.4887 | Test_5 Acc 0.7884 |Train Time 0.397 (0.067) |Test Time 2.293 (1.819)
Epoch 0034 | Train_1 Acc 0.5586 | Train_5 Acc 0.8487 | Test_1 Acc 0.4842 | Test_5 Acc 0.7888 |Train Time 0.371 (0.067) |Test Time 2.316 (1.824)
Epoch 0035 | Train_1 Acc 0.5804 | Train_5 Acc 0.8639 | Test_1 Acc 0.4950 | Test_5 Acc 0.7928 |Train Time 0.460 (0.067) |Test Time 2.154 (1.828)
Epoch 0036 | Train_1 Acc 0.5705 | Train_5 Acc 0.8593 | Test_1 Acc 0.4895 | Test_5 Acc 0.7867 |Train Time 0.365 (0.067) |Test Time 2.088 (1.830)
Epoch 0037 | Train_1 Acc 0.5657 | Train_5 Acc 0.8514 | Test_1 Acc 0.4849 | Test_5 Acc 0.7866 |Train Time 0.444 (0.066) |Test Time 2.384 (1.836)
Epoch 0038 | Train_1 Acc 0.5839 | Train_5 Acc 0.8696 | Test_1 Acc 0.5029 | Test_5 Acc 0.7998 |Train Time 0.381 (0.066) |Test Time 2.125 (1.839)
Epoch 0039 | Train_1 Acc 0.5877 | Train_5 Acc 0.8702 | Test_1 Acc 0.4967 | Test_5 Acc 0.8012 |Train Time 0.470 (0.068) |Test Time 2.246 (1.843)
Epoch 0040 | Train_1 Acc 0.6028 | Train_5 Acc 0.8776 | Test_1 Acc 0.5102 | Test_5 Acc 0.8066 |Train Time 0.436 (0.068) |Test Time 2.377 (1.848)
Epoch 0041 | Train_1 Acc 0.5884 | Train_5 Acc 0.8715 | Test_1 Acc 0.5033 | Test_5 Acc 0.7947 |Train Time 0.437 (0.065) |Test Time 2.283 (1.852)
Epoch 0042 | Train_1 Acc 0.5719 | Train_5 Acc 0.8601 | Test_1 Acc 0.4853 | Test_5 Acc 0.7861 |Train Time 0.408 (0.066) |Test Time 2.869 (1.863)
Epoch 0043 | Train_1 Acc 0.5856 | Train_5 Acc 0.8703 | Test_1 Acc 0.4980 | Test_5 Acc 0.7963 |Train Time 0.386 (0.067) |Test Time 2.349 (1.867)
Epoch 0044 | Train_1 Acc 0.5975 | Train_5 Acc 0.8788 | Test_1 Acc 0.4988 | Test_5 Acc 0.7970 |Train Time 0.369 (0.065) |Test Time 2.057 (1.869)
Epoch 0045 | Train_1 Acc 0.5858 | Train_5 Acc 0.8676 | Test_1 Acc 0.4906 | Test_5 Acc 0.7923 |Train Time 0.365 (0.067) |Test Time 2.641 (1.877)
Epoch 0046 | Train_1 Acc 0.6071 | Train_5 Acc 0.8856 | Test_1 Acc 0.5061 | Test_5 Acc 0.8014 |Train Time 0.398 (0.066) |Test Time 2.116 (1.879)
Epoch 0047 | Train_1 Acc 0.6095 | Train_5 Acc 0.8832 | Test_1 Acc 0.5115 | Test_5 Acc 0.8069 |Train Time 0.436 (0.067) |Test Time 2.246 (1.883)
Epoch 0048 | Train_1 Acc 0.5886 | Train_5 Acc 0.8744 | Test_1 Acc 0.4935 | Test_5 Acc 0.7911 |Train Time 0.399 (0.067) |Test Time 2.201 (1.886)
Epoch 0049 | Train_1 Acc 0.6117 | Train_5 Acc 0.8857 | Test_1 Acc 0.5054 | Test_5 Acc 0.8022 |Train Time 0.461 (0.066) |Test Time 2.156 (1.889)
Epoch 0050 | Train_1 Acc 0.6187 | Train_5 Acc 0.8866 | Test_1 Acc 0.5115 | Test_5 Acc 0.8052 |Train Time 0.364 (0.065) |Test Time 2.074 (1.891)
Epoch 0051 | Train_1 Acc 0.6130 | Train_5 Acc 0.8859 | Test_1 Acc 0.5052 | Test_5 Acc 0.8068 |Train Time 0.435 (0.067) |Test Time 1.997 (1.892)
Epoch 0052 | Train_1 Acc 0.6083 | Train_5 Acc 0.8854 | Test_1 Acc 0.4978 | Test_5 Acc 0.7984 |Train Time 0.448 (0.069) |Test Time 2.051 (1.893)
Epoch 0053 | Train_1 Acc 0.6106 | Train_5 Acc 0.8844 | Test_1 Acc 0.5001 | Test_5 Acc 0.7976 |Train Time 0.381 (0.065) |Test Time 1.988 (1.894)
Epoch 0054 | Train_1 Acc 0.5984 | Train_5 Acc 0.8816 | Test_1 Acc 0.4942 | Test_5 Acc 0.7928 |Train Time 0.412 (0.067) |Test Time 2.292 (1.898)
Epoch 0055 | Train_1 Acc 0.6189 | Train_5 Acc 0.8896 | Test_1 Acc 0.5047 | Test_5 Acc 0.8018 |Train Time 0.385 (0.068) |Test Time 2.081 (1.900)
Epoch 0056 | Train_1 Acc 0.6176 | Train_5 Acc 0.8864 | Test_1 Acc 0.5095 | Test_5 Acc 0.8024 |Train Time 0.422 (0.061) |Test Time 2.228 (1.903)
Epoch 0057 | Train_1 Acc 0.6307 | Train_5 Acc 0.8938 | Test_1 Acc 0.5205 | Test_5 Acc 0.8068 |Train Time 0.384 (0.067) |Test Time 2.079 (1.905)
Epoch 0058 | Train_1 Acc 0.6262 | Train_5 Acc 0.8943 | Test_1 Acc 0.5123 | Test_5 Acc 0.8066 |Train Time 0.358 (0.068) |Test Time 1.886 (1.905)
Epoch 0059 | Train_1 Acc 0.6213 | Train_5 Acc 0.8924 | Test_1 Acc 0.5062 | Test_5 Acc 0.8014 |Train Time 0.396 (0.063) |Test Time 2.093 (1.907)
Epoch 0060 | Train_1 Acc 0.6309 | Train_5 Acc 0.8959 | Test_1 Acc 0.5152 | Test_5 Acc 0.8084 |Train Time 0.357 (0.064) |Test Time 2.359 (1.911)
Epoch 0061 | Train_1 Acc 0.6861 | Train_5 Acc 0.9218 | Test_1 Acc 0.5476 | Test_5 Acc 0.8290 |Train Time 0.417 (0.068) |Test Time 2.222 (1.915)
Epoch 0062 | Train_1 Acc 0.6905 | Train_5 Acc 0.9230 | Test_1 Acc 0.5479 | Test_5 Acc 0.8294 |Train Time 0.390 (0.066) |Test Time 2.067 (1.916)
Epoch 0063 | Train_1 Acc 0.6946 | Train_5 Acc 0.9253 | Test_1 Acc 0.5513 | Test_5 Acc 0.8329 |Train Time 0.407 (0.062) |Test Time 2.242 (1.919)
Epoch 0064 | Train_1 Acc 0.6949 | Train_5 Acc 0.9257 | Test_1 Acc 0.5466 | Test_5 Acc 0.8326 |Train Time 0.377 (0.065) |Test Time 2.224 (1.922)
Epoch 0065 | Train_1 Acc 0.6977 | Train_5 Acc 0.9280 | Test_1 Acc 0.5481 | Test_5 Acc 0.8296 |Train Time 0.396 (0.066) |Test Time 2.027 (1.923)
Epoch 0066 | Train_1 Acc 0.6985 | Train_5 Acc 0.9284 | Test_1 Acc 0.5511 | Test_5 Acc 0.8318 |Train Time 0.418 (0.066) |Test Time 2.126 (1.925)
Epoch 0067 | Train_1 Acc 0.7021 | Train_5 Acc 0.9288 | Test_1 Acc 0.5500 | Test_5 Acc 0.8310 |Train Time 0.427 (0.066) |Test Time 2.151 (1.928)
Epoch 0068 | Train_1 Acc 0.7032 | Train_5 Acc 0.9299 | Test_1 Acc 0.5496 | Test_5 Acc 0.8325 |Train Time 0.416 (0.069) |Test Time 2.082 (1.929)
Epoch 0069 | Train_1 Acc 0.7020 | Train_5 Acc 0.9299 | Test_1 Acc 0.5508 | Test_5 Acc 0.8314 |Train Time 0.424 (0.063) |Test Time 2.117 (1.931)
Epoch 0070 | Train_1 Acc 0.7047 | Train_5 Acc 0.9314 | Test_1 Acc 0.5508 | Test_5 Acc 0.8314 |Train Time 0.400 (0.066) |Test Time 1.974 (1.932)
Epoch 0071 | Train_1 Acc 0.7062 | Train_5 Acc 0.9320 | Test_1 Acc 0.5521 | Test_5 Acc 0.8308 |Train Time 0.354 (0.067) |Test Time 2.101 (1.933)
Epoch 0072 | Train_1 Acc 0.7096 | Train_5 Acc 0.9327 | Test_1 Acc 0.5503 | Test_5 Acc 0.8325 |Train Time 0.352 (0.066) |Test Time 2.229 (1.936)
Epoch 0073 | Train_1 Acc 0.7071 | Train_5 Acc 0.9327 | Test_1 Acc 0.5542 | Test_5 Acc 0.8313 |Train Time 0.396 (0.064) |Test Time 2.296 (1.940)
Epoch 0074 | Train_1 Acc 0.7090 | Train_5 Acc 0.9318 | Test_1 Acc 0.5477 | Test_5 Acc 0.8294 |Train Time 0.375 (0.068) |Test Time 2.852 (1.949)
Epoch 0075 | Train_1 Acc 0.7115 | Train_5 Acc 0.9326 | Test_1 Acc 0.5534 | Test_5 Acc 0.8313 |Train Time 0.405 (0.069) |Test Time 2.865 (1.958)
Epoch 0076 | Train_1 Acc 0.7112 | Train_5 Acc 0.9346 | Test_1 Acc 0.5525 | Test_5 Acc 0.8321 |Train Time 0.437 (0.075) |Test Time 2.514 (1.964)
Epoch 0077 | Train_1 Acc 0.7120 | Train_5 Acc 0.9345 | Test_1 Acc 0.5494 | Test_5 Acc 0.8277 |Train Time 0.440 (0.079) |Test Time 2.739 (1.971)
Epoch 0078 | Train_1 Acc 0.7156 | Train_5 Acc 0.9357 | Test_1 Acc 0.5543 | Test_5 Acc 0.8294 |Train Time 0.422 (0.068) |Test Time 2.705 (1.979)
Epoch 0079 | Train_1 Acc 0.7124 | Train_5 Acc 0.9355 | Test_1 Acc 0.5455 | Test_5 Acc 0.8316 |Train Time 0.517 (0.078) |Test Time 2.775 (1.987)
Epoch 0080 | Train_1 Acc 0.7167 | Train_5 Acc 0.9368 | Test_1 Acc 0.5482 | Test_5 Acc 0.8326 |Train Time 0.450 (0.078) |Test Time 2.852 (1.995)
Epoch 0081 | Train_1 Acc 0.7166 | Train_5 Acc 0.9372 | Test_1 Acc 0.5515 | Test_5 Acc 0.8309 |Train Time 0.506 (0.070) |Test Time 2.730 (2.003)
Epoch 0082 | Train_1 Acc 0.7147 | Train_5 Acc 0.9375 | Test_1 Acc 0.5491 | Test_5 Acc 0.8316 |Train Time 0.443 (0.079) |Test Time 2.821 (2.011)
Epoch 0083 | Train_1 Acc 0.7169 | Train_5 Acc 0.9359 | Test_1 Acc 0.5463 | Test_5 Acc 0.8305 |Train Time 0.459 (0.078) |Test Time 2.874 (2.019)
Epoch 0084 | Train_1 Acc 0.7178 | Train_5 Acc 0.9372 | Test_1 Acc 0.5487 | Test_5 Acc 0.8318 |Train Time 0.422 (0.070) |Test Time 2.727 (2.027)
Epoch 0085 | Train_1 Acc 0.7174 | Train_5 Acc 0.9371 | Test_1 Acc 0.5499 | Test_5 Acc 0.8321 |Train Time 0.476 (0.081) |Test Time 3.260 (2.039)
Epoch 0086 | Train_1 Acc 0.7184 | Train_5 Acc 0.9379 | Test_1 Acc 0.5478 | Test_5 Acc 0.8306 |Train Time 0.377 (0.078) |Test Time 2.867 (2.047)
Epoch 0087 | Train_1 Acc 0.7199 | Train_5 Acc 0.9383 | Test_1 Acc 0.5490 | Test_5 Acc 0.8314 |Train Time 0.377 (0.069) |Test Time 2.648 (2.053)
Epoch 0088 | Train_1 Acc 0.7216 | Train_5 Acc 0.9391 | Test_1 Acc 0.5485 | Test_5 Acc 0.8310 |Train Time 0.421 (0.080) |Test Time 2.915 (2.062)
Epoch 0089 | Train_1 Acc 0.7221 | Train_5 Acc 0.9384 | Test_1 Acc 0.5491 | Test_5 Acc 0.8326 |Train Time 0.457 (0.078) |Test Time 3.245 (2.074)
Epoch 0090 | Train_1 Acc 0.7211 | Train_5 Acc 0.9391 | Test_1 Acc 0.5509 | Test_5 Acc 0.8337 |Train Time 0.505 (0.080) |Test Time 2.821 (2.081)
Epoch 0091 | Train_1 Acc 0.7206 | Train_5 Acc 0.9394 | Test_1 Acc 0.5516 | Test_5 Acc 0.8320 |Train Time 0.466 (0.087) |Test Time 3.058 (2.091)
Epoch 0092 | Train_1 Acc 0.7241 | Train_5 Acc 0.9400 | Test_1 Acc 0.5469 | Test_5 Acc 0.8333 |Train Time 0.513 (0.080) |Test Time 3.292 (2.103)
Epoch 0093 | Train_1 Acc 0.7205 | Train_5 Acc 0.9390 | Test_1 Acc 0.5476 | Test_5 Acc 0.8306 |Train Time 0.565 (0.090) |Test Time 5.635 (2.138)
Epoch 0094 | Train_1 Acc 0.7226 | Train_5 Acc 0.9396 | Test_1 Acc 0.5501 | Test_5 Acc 0.8312 |Train Time 0.555 (0.096) |Test Time 3.254 (2.149)
Epoch 0095 | Train_1 Acc 0.7256 | Train_5 Acc 0.9410 | Test_1 Acc 0.5511 | Test_5 Acc 0.8303 |Train Time 0.593 (0.091) |Test Time 3.720 (2.165)
Epoch 0096 | Train_1 Acc 0.7236 | Train_5 Acc 0.9403 | Test_1 Acc 0.5467 | Test_5 Acc 0.8306 |Train Time 0.592 (0.111) |Test Time 3.984 (2.183)
Epoch 0097 | Train_1 Acc 0.7276 | Train_5 Acc 0.9421 | Test_1 Acc 0.5516 | Test_5 Acc 0.8303 |Train Time 0.524 (0.094) |Test Time 6.352 (2.225)
Epoch 0098 | Train_1 Acc 0.7257 | Train_5 Acc 0.9415 | Test_1 Acc 0.5488 | Test_5 Acc 0.8300 |Train Time 0.632 (0.089) |Test Time 3.274 (2.235)
Epoch 0099 | Train_1 Acc 0.7281 | Train_5 Acc 0.9417 | Test_1 Acc 0.5472 | Test_5 Acc 0.8330 |Train Time 0.580 (0.097) |Test Time 3.704 (2.250)
Epoch 0100 | Train_1 Acc 0.7253 | Train_5 Acc 0.9424 | Test_1 Acc 0.5487 | Test_5 Acc 0.8322 |Train Time 0.559 (0.118) |Test Time 4.260 (2.270)
Epoch 0101 | Train_1 Acc 0.7335 | Train_5 Acc 0.9433 | Test_1 Acc 0.5523 | Test_5 Acc 0.8323 |Train Time 0.657 (0.086) |Test Time 3.601 (2.284)
Epoch 0102 | Train_1 Acc 0.7338 | Train_5 Acc 0.9451 | Test_1 Acc 0.5532 | Test_5 Acc 0.8322 |Train Time 0.526 (0.093) |Test Time 3.255 (2.293)
Epoch 0103 | Train_1 Acc 0.7347 | Train_5 Acc 0.9450 | Test_1 Acc 0.5543 | Test_5 Acc 0.8329 |Train Time 0.647 (0.095) |Test Time 3.640 (2.307)
Epoch 0104 | Train_1 Acc 0.7357 | Train_5 Acc 0.9437 | Test_1 Acc 0.5530 | Test_5 Acc 0.8330 |Train Time 0.481 (0.083) |Test Time 3.151 (2.315)
Epoch 0105 | Train_1 Acc 0.7352 | Train_5 Acc 0.9464 | Test_1 Acc 0.5544 | Test_5 Acc 0.8314 |Train Time 0.632 (0.096) |Test Time 3.028 (2.322)
Epoch 0106 | Train_1 Acc 0.7388 | Train_5 Acc 0.9448 | Test_1 Acc 0.5552 | Test_5 Acc 0.8326 |Train Time 0.577 (0.088) |Test Time 3.560 (2.335)
Epoch 0107 | Train_1 Acc 0.7364 | Train_5 Acc 0.9460 | Test_1 Acc 0.5533 | Test_5 Acc 0.8334 |Train Time 0.551 (0.087) |Test Time 3.229 (2.344)
Epoch 0108 | Train_1 Acc 0.7369 | Train_5 Acc 0.9450 | Test_1 Acc 0.5540 | Test_5 Acc 0.8321 |Train Time 0.574 (0.094) |Test Time 3.266 (2.353)
Epoch 0109 | Train_1 Acc 0.7384 | Train_5 Acc 0.9462 | Test_1 Acc 0.5532 | Test_5 Acc 0.8335 |Train Time 0.640 (0.085) |Test Time 3.400 (2.363)
Epoch 0110 | Train_1 Acc 0.7382 | Train_5 Acc 0.9447 | Test_1 Acc 0.5545 | Test_5 Acc 0.8334 |Train Time 0.529 (0.090) |Test Time 3.116 (2.371)
Epoch 0111 | Train_1 Acc 0.7365 | Train_5 Acc 0.9449 | Test_1 Acc 0.5550 | Test_5 Acc 0.8319 |Train Time 0.630 (0.093) |Test Time 3.567 (2.383)
Epoch 0112 | Train_1 Acc 0.7348 | Train_5 Acc 0.9443 | Test_1 Acc 0.5546 | Test_5 Acc 0.8338 |Train Time 0.581 (0.085) |Test Time 3.642 (2.395)
Epoch 0113 | Train_1 Acc 0.7368 | Train_5 Acc 0.9461 | Test_1 Acc 0.5549 | Test_5 Acc 0.8343 |Train Time 0.552 (0.089) |Test Time 3.295 (2.404)
Epoch 0114 | Train_1 Acc 0.7357 | Train_5 Acc 0.9456 | Test_1 Acc 0.5527 | Test_5 Acc 0.8331 |Train Time 0.563 (0.091) |Test Time 3.409 (2.414)
Epoch 0115 | Train_1 Acc 0.7385 | Train_5 Acc 0.9460 | Test_1 Acc 0.5539 | Test_5 Acc 0.8331 |Train Time 0.515 (0.086) |Test Time 3.222 (2.422)
Epoch 0116 | Train_1 Acc 0.7355 | Train_5 Acc 0.9459 | Test_1 Acc 0.5527 | Test_5 Acc 0.8329 |Train Time 0.539 (0.091) |Test Time 3.278 (2.431)
Epoch 0117 | Train_1 Acc 0.7395 | Train_5 Acc 0.9460 | Test_1 Acc 0.5538 | Test_5 Acc 0.8325 |Train Time 0.595 (0.092) |Test Time 3.179 (2.439)
Epoch 0118 | Train_1 Acc 0.7374 | Train_5 Acc 0.9453 | Test_1 Acc 0.5538 | Test_5 Acc 0.8341 |Train Time 0.559 (0.086) |Test Time 3.474 (2.449)
Epoch 0119 | Train_1 Acc 0.7377 | Train_5 Acc 0.9474 | Test_1 Acc 0.5545 | Test_5 Acc 0.8333 |Train Time 0.525 (0.093) |Test Time 3.267 (2.457)
Epoch 0120 | Train_1 Acc 0.7374 | Train_5 Acc 0.9458 | Test_1 Acc 0.5538 | Test_5 Acc 0.8335 |Train Time 0.586 (0.093) |Test Time 3.380 (2.466)
Epoch 0121 | Train_1 Acc 0.7387 | Train_5 Acc 0.9446 | Test_1 Acc 0.5552 | Test_5 Acc 0.8334 |Train Time 0.592 (0.085) |Test Time 3.354 (2.475)
Epoch 0122 | Train_1 Acc 0.7372 | Train_5 Acc 0.9468 | Test_1 Acc 0.5547 | Test_5 Acc 0.8328 |Train Time 0.525 (0.094) |Test Time 3.249 (2.483)
Epoch 0123 | Train_1 Acc 0.7373 | Train_5 Acc 0.9463 | Test_1 Acc 0.5553 | Test_5 Acc 0.8329 |Train Time 0.545 (0.087) |Test Time 3.467 (2.493)
Epoch 0124 | Train_1 Acc 0.7405 | Train_5 Acc 0.9461 | Test_1 Acc 0.5545 | Test_5 Acc 0.8334 |Train Time 0.578 (0.084) |Test Time 3.253 (2.500)
Epoch 0125 | Train_1 Acc 0.7390 | Train_5 Acc 0.9461 | Test_1 Acc 0.5534 | Test_5 Acc 0.8329 |Train Time 0.590 (0.096) |Test Time 3.441 (2.510)
Epoch 0126 | Train_1 Acc 0.7377 | Train_5 Acc 0.9467 | Test_1 Acc 0.5543 | Test_5 Acc 0.8335 |Train Time 0.558 (0.084) |Test Time 3.600 (2.521)
Epoch 0127 | Train_1 Acc 0.7358 | Train_5 Acc 0.9465 | Test_1 Acc 0.5533 | Test_5 Acc 0.8332 |Train Time 0.572 (0.088) |Test Time 3.232 (2.528)
Epoch 0128 | Train_1 Acc 0.7382 | Train_5 Acc 0.9471 | Test_1 Acc 0.5544 | Test_5 Acc 0.8336 |Train Time 0.570 (0.094) |Test Time 3.398 (2.536)
Epoch 0129 | Train_1 Acc 0.7403 | Train_5 Acc 0.9469 | Test_1 Acc 0.5554 | Test_5 Acc 0.8341 |Train Time 0.573 (0.085) |Test Time 3.458 (2.546)
Epoch 0130 | Train_1 Acc 0.7358 | Train_5 Acc 0.9471 | Test_1 Acc 0.5524 | Test_5 Acc 0.8331 |Train Time 0.520 (0.092) |Test Time 3.207 (2.552)
Epoch 0131 | Train_1 Acc 0.7386 | Train_5 Acc 0.9460 | Test_1 Acc 0.5532 | Test_5 Acc 0.8346 |Train Time 0.636 (0.104) |Test Time 3.532 (2.562)
Epoch 0132 | Train_1 Acc 0.7377 | Train_5 Acc 0.9464 | Test_1 Acc 0.5543 | Test_5 Acc 0.8338 |Train Time 0.594 (0.099) |Test Time 3.562 (2.572)
Epoch 0133 | Train_1 Acc 0.7383 | Train_5 Acc 0.9454 | Test_1 Acc 0.5538 | Test_5 Acc 0.8321 |Train Time 0.661 (0.109) |Test Time 3.858 (2.585)
Epoch 0134 | Train_1 Acc 0.7369 | Train_5 Acc 0.9458 | Test_1 Acc 0.5533 | Test_5 Acc 0.8325 |Train Time 0.757 (0.117) |Test Time 4.083 (2.600)
Epoch 0135 | Train_1 Acc 0.7394 | Train_5 Acc 0.9461 | Test_1 Acc 0.5539 | Test_5 Acc 0.8338 |Train Time 0.744 (0.116) |Test Time 4.257 (2.616)
Epoch 0136 | Train_1 Acc 0.7406 | Train_5 Acc 0.9471 | Test_1 Acc 0.5538 | Test_5 Acc 0.8337 |Train Time 0.792 (0.121) |Test Time 3.742 (2.628)
Epoch 0137 | Train_1 Acc 0.7374 | Train_5 Acc 0.9461 | Test_1 Acc 0.5545 | Test_5 Acc 0.8341 |Train Time 0.689 (0.113) |Test Time 4.213 (2.644)
Epoch 0138 | Train_1 Acc 0.7405 | Train_5 Acc 0.9461 | Test_1 Acc 0.5530 | Test_5 Acc 0.8331 |Train Time 0.638 (0.130) |Test Time 4.061 (2.658)
Epoch 0139 | Train_1 Acc 0.7369 | Train_5 Acc 0.9459 | Test_1 Acc 0.5542 | Test_5 Acc 0.8332 |Train Time 0.823 (0.129) |Test Time 4.717 (2.678)
Epoch 0140 | Train_1 Acc 0.7369 | Train_5 Acc 0.9465 | Test_1 Acc 0.5525 | Test_5 Acc 0.8330 |Train Time 0.766 (0.145) |Test Time 5.210 (2.704)
Epoch 0141 | Train_1 Acc 0.7396 | Train_5 Acc 0.9456 | Test_1 Acc 0.5535 | Test_5 Acc 0.8335 |Train Time 0.823 (0.150) |Test Time 5.324 (2.730)
Epoch 0142 | Train_1 Acc 0.7395 | Train_5 Acc 0.9468 | Test_1 Acc 0.5546 | Test_5 Acc 0.8335 |Train Time 0.803 (0.147) |Test Time 5.894 (2.762)
Epoch 0143 | Train_1 Acc 0.7390 | Train_5 Acc 0.9471 | Test_1 Acc 0.5546 | Test_5 Acc 0.8337 |Train Time 1.961 (0.165) |Test Time 5.922 (2.793)
Epoch 0144 | Train_1 Acc 0.7401 | Train_5 Acc 0.9470 | Test_1 Acc 0.5543 | Test_5 Acc 0.8345 |Train Time 0.980 (1.198) |Test Time 5.831 (2.824)
Epoch 0145 | Train_1 Acc 0.7401 | Train_5 Acc 0.9470 | Test_1 Acc 0.5553 | Test_5 Acc 0.8336 |Train Time 1.241 (0.193) |Test Time 6.071 (2.856)
Epoch 0146 | Train_1 Acc 0.7395 | Train_5 Acc 0.9476 | Test_1 Acc 0.5545 | Test_5 Acc 0.8341 |Train Time 1.143 (0.181) |Test Time 5.348 (2.881)
Epoch 0147 | Train_1 Acc 0.7382 | Train_5 Acc 0.9473 | Test_1 Acc 0.5542 | Test_5 Acc 0.8338 |Train Time 0.911 (0.176) |Test Time 6.639 (2.918)
Epoch 0148 | Train_1 Acc 0.7406 | Train_5 Acc 0.9476 | Test_1 Acc 0.5540 | Test_5 Acc 0.8341 |Train Time 1.050 (0.176) |Test Time 6.806 (2.957)
Epoch 0149 | Train_1 Acc 0.7390 | Train_5 Acc 0.9460 | Test_1 Acc 0.5541 | Test_5 Acc 0.8335 |Train Time 1.073 (0.186) |Test Time 6.106 (2.989)
Epoch 0150 | Train_1 Acc 0.7389 | Train_5 Acc 0.9479 | Test_1 Acc 0.5538 | Test_5 Acc 0.8338 |Train Time 1.085 (0.170) |Test Time 6.798 (3.027)
Epoch 0151 | Train_1 Acc 0.7407 | Train_5 Acc 0.9477 | Test_1 Acc 0.5537 | Test_5 Acc 0.8336 |Train Time 0.953 (0.163) |Test Time 6.552 (3.062)
Epoch 0152 | Train_1 Acc 0.7378 | Train_5 Acc 0.9470 | Test_1 Acc 0.5538 | Test_5 Acc 0.8339 |Train Time 0.999 (0.167) |Test Time 6.320 (3.095)
Epoch 0153 | Train_1 Acc 0.7396 | Train_5 Acc 0.9461 | Test_1 Acc 0.5539 | Test_5 Acc 0.8341 |Train Time 0.979 (0.180) |Test Time 6.326 (3.127)
Epoch 0154 | Train_1 Acc 0.7393 | Train_5 Acc 0.9475 | Test_1 Acc 0.5538 | Test_5 Acc 0.8342 |Train Time 0.965 (0.166) |Test Time 6.340 (3.159)
Epoch 0155 | Train_1 Acc 0.7407 | Train_5 Acc 0.9469 | Test_1 Acc 0.5541 | Test_5 Acc 0.8340 |Train Time 0.916 (0.172) |Test Time 6.937 (3.197)
Epoch 0156 | Train_1 Acc 0.7415 | Train_5 Acc 0.9477 | Test_1 Acc 0.5537 | Test_5 Acc 0.8338 |Train Time 0.830 (0.162) |Test Time 6.914 (3.234)
Epoch 0157 | Train_1 Acc 0.7429 | Train_5 Acc 0.9471 | Test_1 Acc 0.5532 | Test_5 Acc 0.8332 |Train Time 0.977 (0.170) |Test Time 7.248 (3.274)
Epoch 0158 | Train_1 Acc 0.7408 | Train_5 Acc 0.9441 | Test_1 Acc 0.5536 | Test_5 Acc 0.8335 |Train Time 0.901 (0.172) |Test Time 6.464 (3.306)
Epoch 0159 | Train_1 Acc 0.7421 | Train_5 Acc 0.9468 | Test_1 Acc 0.5534 | Test_5 Acc 0.8334 |Train Time 0.858 (0.162) |Test Time 7.035 (3.343)
